{
  parserClass="tech.phosphorus.intellij.prolog.psi.PrologParser"
  parserUtilClass="tech.phosphorus.intellij.prolog.psi.PrologParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Prolog"
  psiImplClassSuffix="Impl"
  psiPackage="tech.phosphorus.intellij.prolog.psi"
  psiImplPackage="tech.phosphorus.intellij.prolog.psi.impl"

  elementTypeHolderClass="tech.phosphorus.intellij.prolog.psi.PrologTypes"
  elementTypeClass="tech.phosphorus.intellij.prolog.psi.PrologElementType"
  tokenTypeClass="tech.phosphorus.intellij.prolog.psi.PrologTokenType"

  psiImplUtilClass="tech.phosphorus.intellij.prolog.psi.impl.SimplePsiImplUtil"

  tokens=[
      SEMI=';'
      COMMA=','
      DOT='.'
      UNIFY=':-'
      NOT='/-'
      LP='('
      RP=')'
      LB='['
      RB=']'
      LIST_CONS='|'
      WILDCARD='_'
      ARITH_EVAL='is'

      space='regexp:\s+'
      comment='regexp:(%.*)'
      integer='regexp:\d+'
      float='regexp:\d+(\.d+)?' // strict floating mode
      const_id='regexp:\p{Lower}\p{Alnum}*'
      atom_id='regexp:\p{Upper}\p{Alnum}*'
      operator_id='regexp:[<=>:!+\-*/]+' // considering that operators in prolog can fly everywhere...
      string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    ]
}

root ::= rule*
private rule ::= !<<eof>> expr_head (':-' expr_body)? '.'

expr_head ::= predicate

expr_body ::= primary

predicate ::= predicate_id parameter_list?

predicate_id ::= const_id

parameter_list ::= '(' primary? ')'

logical_or ::= ';' primary

logical_and ::= ',' primary

logical_not ::= '/-' primary

arithmetic_eval ::= 'is' primary

equiv_binary ::= ( logical_not | logical_and | arithmetic_eval )

literal ::= string | integer | float

list_constructor ::= '[' ']' | '[' primary '|' primary ']' | '[' primary ']'

common_val ::= predicate | ident | literal | list_constructor | '_'

private primary ::= (common_val | logical_not | operator_id) (common_val | equiv_binary | logical_or  | operator_id)*

ident ::= (const_id | atom_id)
